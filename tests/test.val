-- this is the first code ever written and compiled in valdemar

fn sq (a double_t) -> double_t {
    ret a * a
}

fn add_sq (a double_t, b double_t) -> double_t {
    ret sq(a) + sq(b)
}

fn inc (a double_t) -> double_t {
    ret a + 1.0
}

ext_c sin (a double_t) -> double_t

fn cos_sq (a double_t) -> double_t {
    ret 1.0 - sq(sin(a))
}

fn locals() -> double_t {
    val pi double_t = 3.14
    val a double_t = cos_sq(pi)
    ret a * pi * 2.0
}

ext_c print_float (a double_t) -> unit_t

fn side_effects(a double_t) -> unit_t {
    print_float(a)
}

fn booleans(a bool_t, b bool_t) -> bool_t {
    ret a | b & b
}

fn no_braces(a double_t) -> double_t ret 2.0 * a

fn branching (a double_t, more bool_t) -> unit_t {
    if more {
        print_float(a + 1.0)
        print_float(a + 2.0)
    }

    if not more print_float(a - 1.0)
}

fn count_down(a double_t) -> unit_t {
    if a > 0.0 {
        print_float(a)
        count_down(a - 1.0)
    }
}

fn vald_fabs(a double_t) -> double_t {
    if a < 0.0 ret a * -1.0
    ret a
}

fn compare_float (a double_t, b double_t, eps double_t) -> bool_t
    ret vald_fabs(a - b) < eps

fn mutability () -> unit_t {
    mutval a double_t = 0.0
    a = a + 1.0
    if a > 0.0 {
        a = a + 2.0
    }
    print_float(a)
}

fn get_int() -> int_t ret 4

fn arrays () -> unit_t {
    val arr ^[double_t] = [1.0, 2.1, 3.2]
    val item double_t = arr[0]
    print_float(item)
    print_float(arr[1])
    print_float(arr[2])

    val ints ^[int_t] = [1, 2, 3]
    val iteger int_t = ints[0]

    val bools ^[bool_t] = [true, false]
    if bools[0] {
        print_float(arr[2])
    }
}

fn out_of_range () -> unit_t {
    val values ^[double_t] = [1.0, 2.0, 3.0, 4.0, 5.0]
    print_float(values[5])
}

fn count_down2 (a double_t) -> unit_t {
    while a > 0.0 {
        a = a - 1.0
        print_float(a)
    }
}

ext_c print_char (c byte_t) -> unit_t
ext_c print_int (c int_t) -> unit_t

fn strings () -> unit_t {
    val the_best_letter byte_t = 'M'
    print_char(the_best_letter)
    print_char(' ')

    val at_last str_t = "hello, world"
    val the_same_as_above ^[byte_t] = "oh, hai"

    print_char(at_last[0])
}

fn print (string str_t) -> unit_t {
    mutval i int_t = 0
    while i < #string {
        print_char(string[i])
        i = i + 1
    }
    print_char('\n')
}

fn array_assignment () -> unit_t {
    val hello str_t = "hello, world"
    hello[0] = 'H'
    print(hello)
}

fn type_conversions () -> unit_t {
    if double_t(1 + 2) == 3.0
        print("int_t -> double_t works.")
    if int_t(3.2 + 2.1) == 5
        print("double_t -> int_t works.")
    if int_t('M') == 77
        print("byte_t -> int_t works.")
    if byte_t(77) == 'M'
        print("int_t -> byte_t works.")
}

-- anonymous tuple: (double_t, double_t)
-- named tuple:
tuple complex_t {
    real double_t,
    imag double_t,
}

tuple vec3_t {
    x, y, z double_t
}

-- fn mutate(a ^complex_t) -> unit_t {
--     a->imag = 1.0
-- }

fn zeros () -> (double_t, double_t, double_t) {
    ret (0.0, 0.0, 0.0)
}

fn structs () -> unit_t {
    val position vec3_t = (0.0, 1.0, 2.0)
    val target vec3_t = zeros()
    --print_float(position.y)
}

fn arg_packs (a, b, c double_t) -> double_t {
    ret a + b * c
}

fn main () -> unit_t {
    print_float(arg_packs(1.0, 2.0, 3.0))
    structs()
}

